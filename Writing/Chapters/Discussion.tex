\chapter{Discussion}

\section{Related work}

\paragraph*{}
The paper on RA, secure and trusted boot on IoT Nodes \cite{LingZhen2021Sbtb} is the paper on which the implementation and experiments of this thesis are based, and is extensively explained in the background section. To provide a better understanding of the effectiveness of their solution, it is compared to three related works. Preceding this comparison, these three papers are briefly explained with in depth explanations on the parts that are most relevant for the comparison. The main focus of this comparison will be on the added security guarantees and the assumptions that have been made with respect to the RA. After the comparisons of the related work, the weaknesses and possible improvements of the work performed in this thesis will be discussed.

\subsection*{SecTEE: A Software-based Approach to Secure Enclave Architecture Using TEE}

\paragraph*{}
The solution described in the paper about SecTEE \cite{ZhaoShijun2019SASA} aims to implement a framework using ARM TrustZone to achieve similar security guarantees as a hardware-based secure enclave architecture. The authors provide the following contributions with their paper. Their first contribution is the implementation of SecTEE, the new secure enclave architecture which achieves \textit{\enquote{the highest level of security}} using ARM TrustZone. Secondly, a locking mechanism is introduced which makes sure enclave pages cannot be accessed while the enclave is running to prevent cross-core side-channel attacks. The TEE OS is also extended to provide functionality like identification, RA, and sealing sensitive data. Lastly, an implementation of SecTEE based on OP-TEE is provided along with experiments showing the performance of the proposed system. 

\paragraph*{}
Their wording of \textit{\enquote{the highest level of security}} means that it should be resistant to privileged host software attacks, board-level physical attacks, page fault based side-channel attacks, and cache based side-channel attacks. The hardware attacks on which is focused are cold boot attacks \cite{HuberManuel2016Afff}, bus monitoring attacks \cite{TPMGenie}, and Direct Memory Access (DMA) attacks. Attacks against the internal state of the SoC are not considered, because those are assumed to be very sophisticated and require expensive equipment. To achieve this security, certain requirements are necessary. First of all, a Device Sealing Key (DSK) needs to be present. This is a symmetric key only known by the device itself and used to protect secrets related to the device. Also needed is a Device Root Key (DRK), which is an asymmetric key pair necessary to identify and authenticate the device. Lastly, the manufacturer's public key needs to be hard coded on the device to make sure it is able to verify the signature on software updates from the manufacturer. 

\paragraph*{}
An important aspect of the SecTEE architecture is the method that is applied for memory protection. SecTEE protects enclaves from physical attacks by using a similar approach as the OP-TEE pager. It is an on-demand paging system which runs the entire TEE system on OCM. Whenever a page leaves this OCM, it is encrypted to ensure confidentiality and integrity of the data while it is stored on the Dynamic Random Access Memory (DRAM). Another key feature of SecTEE is its side-channel resistance. Side-channel attacks from the SW are avoided by using a page coloring mechanism. Different enclaves can never share the same cache set, which ensures that one enclave will never be able to evict cache lines of another one. Of course, side-channel attacks can also come from the NW, especially because the NW and SW share the same cache in the ARM TrustZone architecture. In the NW, there are of course certain limitations to what is possible with the cache lines due to privilege restrictions. Nonetheless, the prime and probe method is still relevant in this case. SecTEE cleans and invalidates all cache levels when the Central Processing Unit (CPU) switches from the SW to the NW. This, however, is not sufficient because cross-core side-channel attacks can launch the attack, while a core of the CPU is still executing in the SW. To handle this problem, the cache set of the enclave is locked, which guarantees that the cache of the enclave cannot be probed or manipulated by the NW. Some final aspects that deserve some highlighting are enclave identification, measurement, and RA in SecTEE. Enclaves are published along with the public key of the author and the signed integrity value of the image. With this information the enclave can be verified and identified before it is run. During runtime, the enclave keeps track of important aspects like enclave identifier, integrity, and a flag indicating whether it is privileged. For the RA a specific quoting enclave is created. This is a privileged enclave that can make the system calls related to the management of attestation keys, other enclaves are not allowed to do this. These keys are used to sign the report data of the attestation together with the runtime measurement to provide proof to the verifier that it comes from the correct enclave.

\paragraph*{}
First of all, the number of lines of code are measured because these implementations extend the TEE kernel. This is the TCB and needs to be kept minimal because bugs could easily introduce security vulnerabilities. Next, the overhead of the trusted computing features is identified and discussed. This overhead is acceptable in case Elliptic Curve Cryptography (ECC) with keys of 256 bits are used, some system calls take too long in case Rivest-Shamir-Adleman (RSA) keys of 2,048 bits are used. The performance of certain enclaves was measured and the xtest benchmark of OP-TEE was executed. SecTEE was about 4 times slower than OP-TEE on the benchmark and 40 times slower than OP-TEE on the enclave execution. It is argued that the memory protection mechanism is the cause of the greatest performance overhead in SecTEE. Finally, to test the effectiveness of the side-channel defense, the effectiveness of the attack on plain OP-TEE is compared to the case of SecTEE. In case of a NW attack, there is a clear difference between prime and probe timings in OP-TEE while both memory operations take an equal amount of time when using SecTEE. This makes it impossible for an attacker to learn anything about the cache behavior of the victim enclave in SecTEE. For the SW attack an Advanced Encryption Standard (AES) key could be recovered after 256,000 encryptions in OP-TEE, while in SecTEE the attacker could not learn any information about the used key.

\subsection*{TrustShadow: Secure Execution of Unmodified Applications with ARM TrustZone}

\paragraph*{}
TrustShadow \cite{GuanLe2017TSEo} is designed to protect existing applications from untrusted OSs without the need to modify the applications themselves. This is achieved by using TrustShadow as a lightweight runtime system that shields the sensitive information of the application from the OS. This system does not provide system services itself but requests them from the OS. It does, however, guarantee security through encryption, context switching and verifying return values. To ensure that the OS cannot get hold of the encryption keys, sensitive data, and cannot interfere with the security verification, TrustShadow runs in the SW of the ARM TrustZone processor.

\paragraph*{}
The solution described in the paper about TrustShadow is mainly focused on protecting applications from an untrusted OS. This means that the attacker is able to launch DMA attacks, modify interrupted process states, change program execution control flow, hijack system services, and control communication channels \cite{QiangChenyi2018CCAD}. DoS attacks and side-channel attacks such as timing and power analysis are not taken into account in this solution.

\paragraph*{}
The memory of the different stakeholders is isolated from each other to make sure the rich OS is not able to tamper with the memory of the applications and with the runtime system. TrustShadow utilizes the TZASC to make three partitions in memory: one unprotected for the applications, one protected for the applications and one protected for the runtime system itself. The virtual memory space is equally distributed between the OS and the runtime system TrustShadow. The runtime system also maps the physical address space holding the OS to efficiently locate shared memory. Another aspect that needs to be taken into account, is that the OS is used to handle exceptions. When an exception is thrown, the state of the application is stored and the state of the OS is restored. The runtime system then reproduces the exception in this OS state to allow the OS to handle it without the need to get sensitive details about the application. There are two exceptions that the runtime system implemented in the SW, namely, the random number generation, and floating point operations. Since the cryptography relies on the security of these exceptions they are security critical. System calls are similar to exceptions: the OS needs some information about the application requesting the system call. TrustShadow sanitizes this information to make sure only the necessary data is received by the OS. After receiving the result from the system call, the runtime system also checks this result on correctness before forwarding it to the application. An example of sensitive information that an untrusted OS should not have access to is the memory mapping from virtual to physical address space. This information is stored in the page tables. TrustShadow makes use of the OS page fault handler to update and retrieve the page table entries that are stored in the SW. This ensures that the rich OS does not require the information because it is controlled by the runtime system. After the memory location of a page has been found, this can be loaded for execution. Before this loading is finished, however, the page is checked on its integrity. TrustShadow verifies the executable pages of an application and the executable pages of the shared libraries based on a manifest file related to the application. 

\paragraph*{}
TrustShadow was evaluated with a variety of measuring methods. Microbenchmarks using LMBench, file operations using Sysbench, HTTP and HTTPS request handling using Nginx, and finally, the performance overhead on data analytic applications. The performance overhead caused by the runtime system was negligible across all tests. In terms of security, the OS still has a lot of control: it could, for instance, invoke a system call with the original \textit{execve} instead of the new \textit{tz\_execve} which largely bypasses TrustShadow. Another concern is the possibility to manipulate or forge manifest files which could allow an attacker to tamper with the code of an application without the runtime system being able to detect it. 

\subsection*{TZ-MRAS: A Remote Attestation Scheme for the Mobile Terminal Based on ARM TrustZone}  

\paragraph*{}
In this paper \cite{WangZiwang2020TARA}, a TrustZone based Mobile Remote Attestation Scheme (TZ-MRAS) is proposed. There are three main challenges the authors tackle, the first one is building a RoT for measuring, storage, and reporting of the attestation results. The second challenge is to execute binary-based attestation on hardware constrained devices while defending against TOC-TOU attacks. The last challenge consists of the performance optimization of storing measurement logs in a hash tree which has considerable overhead during the construction and updating phases. 

\paragraph*{}
The assumptions of the TrustZone model are followed, meaning that the processor is trusted and a CoT is achieved to trusted applications. The SW is the TCB and it provides features to attest the integrity of the NW. The attacker, on the other hand, is assumed to have kernel level access, meaning he can tamper with the REE kernel and applications in any way he desires. DoS and side-channel attacks are not considered in this paper.

\paragraph*{}
To tackle the first challenge related to the root of trust, the functionality of a TPM chip is provided by the TEE of TrustZone. These functionalities are implemented in TA's running in the SW to ensure isolation from the NW. The measurement module keeps track of REE and dynamically detects integrity changes in the kernel, but can also update the Secure Measurement Log (SML). Secondly, the TOC-TOU attacks are protected against by updating the SML with a dynamic update mechanism, namely ProbeIMA. Probes are added to all operations that are able to modify the code pages of the kernel, meaning that any attempt to execute any of these operations will be detected. Lastly, the structure of the SML is optimized by storing the root node in a hardware protected register and the rest of the hash tree in secure memory. Also, the design related to the construction, insertion and revocation algorithms avoids too frequent construction and update operations to increase performance.

\paragraph*{}
The performance overhead in terms of execution time difference, is only touched on shortly. Because this is less than 10\% in the worst case, which is very acceptable. Besides the performance overhead, the security analysis is backed up with experiments that show the solution works, and is able to detect the attacks used. The simulated attacks are a rootkit that hijacks the kernel function of the system call table and a TOC-TOU attack that modifies the code pages, and restores them again in between integrity checks. Lastly, the depth of the hash tree is measured for a varying amount of updated nodes, mainly to prove that the construction and updates on those trees have a limited impact on performance.

\section{Comparison of Approaches}

\subsection*{Effectiveness}

\paragraph*{}
All solutions focus on measuring the binaries of the executable files to verify the integrity of the runtime system. This is achieved by having a TA in the SW which does the measurements, stores the results, and encrypts them before sending them to the RA server. Running the attestation inside the SW shields the attestation process from being tampered with by the NW. But it does not guarantee that the execution control flow of the attested applications cannot be tampered with. SecTEE seems to keep track of more data for the attestation process, but nothing is said about the integrity of data structures or other critical parts of the system. 

\paragraph*{}
Except for the paper on SecTEE, all solutions have a very similar goal and their solutions are also very comparable. All three solutions (TrustShadow, TZ-MRAS and the trusted boot) mainly focus on the attestation of NW processes, but these are not very well shielded or isolated from the rich OS. SecTEE uses RA as one of the many tools to protect the applications or at least identify violations thereof. Due to the effort the authors of SecTEE put into the memory protection scheme, the page coloring mechanism and the way enclaves need to be implemented, it achieves better security guarantees for the enclaves. An enclave has to be implemented as a TA, which by itself introduces additional security guarantees like, it being infeasible for the rich OS to tamper with the execution control flow of the enclave.

\paragraph*{}
None of the solutions mentioned give much attention to the openness of the secured system. SecTEE, for instance, requires a private public key pair from the manufacturer to function, which entirely closes the solution towards the user and third parties that may also provide useful software. The DRK used in that architecture could serve as the RoT of the device. The other examples do not explicitly mention how the RoT is achieved, only that it is stored in tamper resistant storage hardware. This is, however, a very important detail when validating the openness of the final system.

\subsection*{Assumptions}

\paragraph*{}
All solutions assume an IoT device or smartphone device meaning, the solutions need to be adapted to devices with limited hardware specifications. Based on this assumption, all compared solutions chose for ARM SoC with TrustZone capabilities. In this context the SW of ARM TrustZone, along with its TAs, are all assumed to be trusted and secure and isolated from the rich OS. In the case of SecTEE, the additional assumption is made that the enclaves (isolated applications) are written as TAs, which may be feasible for an open platform. Although when these enclaves need to be signed by a manufacturer's private key, it achieves an entirely different goal. On the other hand, the other solutions claim to attest the NW and provide similar protection against the rich OS, which is unfeasible if only the code pages of an application are measured for integrity violations. 

\paragraph*{}
SecTEE claims to protect against certain side-channel attacks and hardware attacks like DMA and cold boot attack. These claims seem to be met thanks to the SW being instantiated in a trusted manner with secure boot and the protected code running in the SW. The papers about TrustShadow and TZ-MRAS acknowledge that side-channel attacks are not dealt with, but DMA attacks are prevented by protecting the address space mapping and encrypting the stored data. The reproduced solution does not give specific details about side-channel attacks or DMA attacks, it only mentions hardware, software, and OS attacks. These claims seem excessive, because only the attestation TA itself is protected against these kinds of attacks, due to the TEE and trusted boot. The applications in the NW are still vulnerable to many attacks of which only a few (changing the executable code of the application) are detected by the solution. Last but not least, OS attacks cannot be prevented using this method. An attack can in some cases (depending on what is modified) be detected with RA, but none of the solutions make an effort to make attacking the OS harder. This is due to it not being considered when discussing the applications running in the NW.

\section{Reflection}

\paragraph*{}
First of all, a consideration needs to be made with respect to the RoT of the system. The discussed related work does not take into account the openness of the system, and thus does not discuss this in detail. The PinePhone is equipped with tamper resistant storage hardware, which could accommodate the RoT. This detail on what exactly is stored in this memory and how this information is generated, has a large impact on whether the system remains open. If the user is allowed to put a public key in the secure storage, of which he and only he possesses the secure counterpart, the solution remains open. The security, of course, depends on how well the user is able to protect his private key, but this is out of scope for this work. This is, however, how we believe a RoT can be achieved for an open system. In case the device is sold second-hand, there is of course a problem, because the buyer needs to trust the first owner in order for this deal to work. Since the original user possesses the private key, and it is hard to prove that when the buyer receives this key, the initial owner does not have access to this key anymore. This is interesting, but goes beyond realizing a secure RoT for an open platform.

\paragraph*{}
Our solution avoids the trusted third party that needs to be convinced that the integrity of the software running on the device is not violated. The only party that needs to be assured about the integrity of the system is the user. Based on our implementation we can claim that the NW process integrity checking works. To become a complete security solution, certain extensions will need to be made which are discussed in the future work. Taking these considerations into account, we believe that user-controlled attestation can be used to increase the security of an open platform without disrupting the openness of the system.

\paragraph*{}
The evaluation gives insight in how well this solution meets the expectations of the smartphone user. The performance is not ideal as elaborately discussed earlier, but this was not the main goal of the proof of concept. Making sure the solution meets the expectations of the user is one thing, but the software providers need to be confident about their guarantees as well. Right now the user decides which software can run on the device. By doing so he is assumed to trust the software provider. A software provider is only guaranteed that, other software running on the platform comes from providers that are trusted by the user. This guarantee is not very strong, since there is a possibility that the user trusts a malicious provider which could try to tamper with the processes of other providers. If software providers need additional guarantees, the attestation solution should be extended to provide these security measures, some examples of these measures are given in the future work. Even though guaranteeing the software providers correct execution control flow of their processes seems evident, it does have implications on the user's freedom to operate the device. This leans more towards the philosophical side of the open platform idea so we will not dive in too deep about this.

\paragraph*{}
The solution in this thesis differs from \cite{LingZhen2021Sbtb}, in the sense that the initial measurement results are stored in the secure memory of the SW instead of at a RA server. Storing these values on the device itself, allows for the solution to be extended, and allow the user to attest the device. Depending on how the user reacts to this information, similar security guarantees can be provided as the closed systems. All related work that we have discussed, relies on the integrity and confidentiality of the secure memory of ARM TrustZone. Furthermore, the execution control flow of the TAs is always assumed to be protected against adversaries whether they attack with software attacks, OS attacks, or certain hardware attacks. The solution presented in the implementation also relies on these features to store the initial hash digests and perform the comparisons with the newly measured values, respectively. Due to these assumptions already being present they do not weaken the security of the proposed system compared to the closed systems.

\section{Future Work}

\subsection*{Considerations}

\paragraph*{}
One important sensitivity point is to decide whether every page in an executable memory region gets its own hash value or whether all the pages in this memory region get one combined hash value. The fine-grained option allows to only measure the code pages that are currently loaded into the RAM. This is sufficient, because the executable page can only start being executed when it is located in RAM. If, on the other hand, all pages of the region need to be measured, the unused pages also need to be loaded into RAM to be able to measure them. The downside to the fine-grained option is that more initial values need to be stored, since every page has its own value.

\paragraph*{}
Another trade-off that could be put forth, is the hashing algorithm that is used to measure the memory pages. The hashing algorithm needs to adhere to certain requirements like avoiding collisions, but a Hash-based Message Authentication Code (HMAC) algorithm that uses a key during the hashing process, is definitely excessive. The hashing mainly needs to be fast, because lots of memory pages need to be attested and this needs to happen relatively often to guarantee improved security. The hash digests do not need to be secure in the sense of being unforgeable. They are stored in secure memory which cannot be tampered with, meaning the attacker is not able to replace the initial values with a malicious one. With the initial values assumed secure, the hash digests are merely used to detect whether the hashed information has changed or not, for which a normal hashing algorithm is sufficient due to its collision avoidance.

\paragraph*{}
Lastly, it was found out that in a recent framework update of OP-TEE an attestation PTA was added to the kernel \cite{OPTEE3.17}. The PTA in that solution attests the SW processes (TAs), which is different from the implementation presented in this thesis, since we focus on checking the integrity of the processes in the NW. This also implies that the added PTA in the kernel provides asymmetric key encryption to communicate with a remote verifier in a secure manner. The update notes clearly state that RA was intended, so these differences are definitely in line with the expectations. Even though there are certain differences, it is definitely possible to change the implementation 'slightly' to make it fit into this provided attestation PTA and reuse some of its already present functionality. This could be the beginning of a more standardized form of NW integrity checks if the shortcomings have been dealt with.

\subsection*{Shortcomings}

\paragraph*{}
In the proposed solution, there is still a strong dependency upon the rich OS. This dependency mainly comes from the files that are used to determine the physical addresses of pages related to the processes that are measured. These files are part of the data structures the rich OS owns. A solution to this problem could be to move the responsibility of the memory mapping into the SW. The downside to this is that it increases the TCB, because the SW is often seen as the TCB. This can however be achieved in a relatively lightweight fashion, as demonstrated in the TrustShadow paper where the page table is stored inside the SW, and the SW handles page faults that are generated in the rich OS. 

\paragraph*{}
Partial attestation introduces a fake sense of security, because not all possible attacks are checked. We have mentioned that the execution control flow of an application can be tampered with through the manipulation of data structures. There are lots of ways similar attacks can be achieved to make applications behave differently than intended. Some solutions protect better against some of these attacks than others, like checking the results of a system call executed by the rich (untrusted) OS. \cite{MuhlbergJanTobias2016LaFT} describes a variety of possible aspects for which integrity checks are useful to increase the level of trust one can have in an application. These properties vary from OS data structures, available resources to event occurrence and timing. This is probably harder to achieve when trying to protect against a rich OS like Linux compared to the Contiki OS that was used, but it looks like a promising direction for future work.

\paragraph*{}
The attestation measurements are performed, software integrity checks in our case, but there is no way to interact with this information yet. To allow the user to perform user-controlled attestation, he needs to be informed about the results of these measurements. To make sure this is achieved in a secure manner, the trusted I/O channels in ARM TrustZone can be used. Through these channels the user could also command the system to take certain actions with respect to the processes that have been tampered with. By doing this the user is in control with respect to how software integrity violations are handled.

\paragraph*{}
Finally, if software providers need to be guaranteed that the execution control flow of their programs is not tampered with, an extension is necessary. For instance, the ability to identify applications violating security measures like trying to tamper with other applications or the rich OS. The user should be notified about this and be strongly advised to remove those malicious applications from his device. A solution could be opted for where the process is terminated if any inconsistencies are detected. This would increase the guarantees that can be provided with respect to the proper execution of programs from certain software providers. It would of course be better if it were infeasible to tamper with another process, but we believe this is not achievable with user-controlled attestation or any form of attestation alone.